Your task is to develop a subclass to the Strategy named UserSrategy, following the 
details of the prompt below. The details of the prompt detail the strategy to implement.

Below there's a library provided with some core classes and methods that must be 
interfaced with but feel free to override and implement as necesary. Along with that,
an example of a prompt and an output UserStrategy class for said prompt with a
subsequent example of a backtest module backtesting said class.

All the code necessary must be contained within a single file which will be executed
in the root folder so utilisation of full path imports is a must.

The output should be no more than the UserStartegy class and all other necessary
functions, variables etc that you choose to implement.

Prompt:
Build a startegy that longs when the price is greater than the average of the last 3
prices and vice versa for shorts

Library:
// src\config.py (L1-L60)
import logging
import os
import sys
from datetime import timedelta
from urllib.parse import quote

from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.ext.asyncio import create_async_engine


load_dotenv()

PRODUCTION = False


# Paths
BASE_PATH = os.path.dirname(__file__)
RESOURCES_PATH = os.path.join(BASE_PATH, "resources")


# Auth
COOKIE_ALIAS = "strat-builder-cookie"
JWT_ALGO = "HS256"
JWT_SECRET = os.getenv("COOKIE_SECRET", "secret")
JWT_EXPIRY = timedelta(days=1000)


# DB
DB_HOST_CREDS = f"{os.getenv("DB_HOST", "localhost")}:{os.getenv("DB_PORT", 5432)}"
DB_USER_CREDS = f"{os.getenv("DB_USER", "postgres")}:{quote(os.getenv("DB_PASSWORD"))}"
DB_NAME = os.getenv("DB_NAME")
DB_ENGINE = create_async_engine(
    f"postgresql+asyncpg://{DB_USER_CREDS}@{DB_HOST_CREDS}/{DB_NAME}"
)
DB_ENGINE_SYNC = create_engine(
    f"postgresql+psycopg2://{DB_USER_CREDS}@{DB_HOST_CREDS}/{DB_NAME}"
)


# Logging
logging.basicConfig(format="%(asctime)s - [%(levelname)s] - %(module)s - %(message)s")
logger = logging.getLogger()
logger.setLevel(logging.INFO)

handler = logging.StreamHandler(sys.stdout)
handler.setFormatter(
    logging.Formatter("%(asctime)s - [%(levelname)s] - %(module)s - %(message)s")
)
logger.addHandler(handler)


# Resources
fpath = os.path.join(RESOURCES_PATH, "system-prompt.txt")
if not os.path.exists(fpath):
    SYSTEM_PROMPT = None
    logger.warning(f"System prompt not found at {fpath}")
else:
    SYSTEM_PROMPT = open(fpath, "r").read()


// src\core\enums.py (L61-L84)
from enum import Enum


class StrategyType(Enum):
    FUTURES = 0
    SPOT = 1


class Side(Enum):
    ASK = 0
    BID = 1


class OrderType(Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"


class PositionStatus(Enum):
    PENDING = 0
    OPEN = 1
    CLOSED = 2


// src\db_models.py (L85-L190)
from datetime import datetime
from decimal import Decimal
from uuid import uuid4

from sqlalchemy import UUID, DateTime, Float, String, ForeignKey, Integer
from sqlalchemy.orm import DeclarativeBase, mapped_column, Mapped, relationship

from utils import get_datetime


class Base(DeclarativeBase): ...


class Users(Base):
    __tablename__ = "users"

    user_id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid4
    )
    username: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)
    password: Mapped[str] = mapped_column(String, nullable=False)

    strategies: Mapped[list["Strategies"]] = relationship(
        back_populates="user", cascade="all, delete-orphan"
    )
    positions: Mapped[list["Positions"]] = relationship(
        back_populates="user", cascade="all, delete-orphan"
    )


class Ticks(Base):
    __tablename__ = "ticks"

    tick_id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid4
    )
    instrument: Mapped[str] = mapped_column(String, nullable=False)
    last_price: Mapped[Decimal] = mapped_column(Float, nullable=False)
    bid_price: Mapped[Decimal] = mapped_column(Float, nullable=False)
    ask_price: Mapped[Decimal] = mapped_column(Float, nullable=False)
    time: Mapped[int] = mapped_column(Integer, nullable=False)  # Unix Epoch seconds


class Strategies(Base):
    __tablename__ = "strategies"

    strategy_id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid4
    )
    user_id: Mapped[UUID] = mapped_column(ForeignKey("users.user_id"), nullable=False)
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, default=get_datetime
    )

    # Relationships
    user: Mapped["Users"] = relationship(back_populates="strategies")
    versions: Mapped[list["StrategyVersions"]] = relationship(
        back_populates="strategy", cascade="all, delete-orphan"
    )


class StrategyVersions(Base):
    __tablename__ = "strategy_versions"

    version_id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid4
    )
    name: Mapped[str] = mapped_column(String, nullable=False)
    strategy_id: Mapped[UUID] = mapped_column(
        ForeignKey("strategies.strategy_id"), nullable=False
    )
    code: Mapped[str] = mapped_column(String, nullable=False)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, default=get_datetime
    )

    # Relationship
    strategy: Mapped["Strategies"] = relationship(back_populates="versions")
    positions: Mapped[list["Positions"]] = relationship(
        back_populates="strategy_versions", cascade="all, delete-orphan"
    )


class Positions(Base):
    __tablename__ = "positions"

    position_id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid4
    )
    user_id: Mapped[UUID] = mapped_column(ForeignKey("users.user_id"), nullable=False)
    version_id: Mapped[UUID] = mapped_column(
        ForeignKey("strategy_versions.version_id"), nullable=False
    )
    size: Mapped[Decimal] = mapped_column(Float, nullable=False)  # contracts/shares
    entry_price: Mapped[Decimal] = mapped_column(Float, nullable=False)
    timestamp: Mapped[int] = mapped_column(
        Integer, nullable=False
    )  # Unix Epoch seconds

    # Relationships
    user: Mapped["Users"] = relationship(back_populates="positions")
    strategy_versions: Mapped["StrategyVersions"] = relationship(
        back_populates="positions"
    )


// src\lib\__init__.py (L191-L198)
"""
This package serves as a guard rail for the 
models when developing the user's strategy.
"""

from .backtest import Backtest
from .enums import TradingPlatform
from .strategy import Strategy

// src\lib\backtest.py (L199-L277)
from decimal import Decimal

import pandas as pd

from core.enums import OrderType, PositionStatus
from lib.exchanges import BacktestFuturesExchange
from lib.typing import BacktestResult
from .order_managers import BacktestFuturesOrderManager
from .strategy import Strategy


class Backtest:
    """
    To be used to perform a backtest, evaluating
    the performance of strategy on experimental data.
    """

    def __init__(
        self,
        strat: Strategy,
        df_path: str | None = None,
        df: pd.DataFrame | None = None,
        starting_balance: float = 100_000,
        leverage: int = 10,
    ) -> None:
        self._starting_balance = starting_balance
        self._om = BacktestFuturesOrderManager(
            starting_balance=starting_balance, leverage=leverage
        )
        self._om._exchange = BacktestFuturesExchange({}, df_path, df)
        strat._om = self._om
        self._strat = strat

    def run(self) -> BacktestResult:
        with self._strat:
            for tick in self._om._exchange.subscribe(""):
                # Placing and closing trades
                positions = list(self._om._positions.values())
                for pos in positions:
                    if pos.status == PositionStatus.OPEN:
                        if (pos.sl_price is not None and pos.sl_price == tick.last) or (
                            pos.tp_price is not None and pos.tp_price == tick.last
                        ):
                            self._om.close_position(
                                pos.id, tick.last, pos.current_amount
                            )
                    elif pos.order_type in (OrderType.LIMIT, OrderType.STOP):
                        pos.status = PositionStatus.OPEN

                self._om.perform_risk_checks(tick)
                self._strat.run(tick)

        return self._get_backtest_result()

    def _get_backtest_result(self):
        closed_count = len(self._om._closed_positions)
        total_trades = len(self._om._positions) + closed_count
        win_rate = sum(
            1
            for pos in self._om._closed_positions
            if pos.realised_pnl and pos.realised_pnl >= 0.0
        )

        total_pnl = Decimal("0.0")
        for pos in self._om._closed_positions:
            total_pnl += pos.realised_pnl

        for pos in self._om.positions:
            total_pnl += pos.realised_pnl

        res = BacktestResult(
            total_pnl=total_pnl,
            starting_balance=self._starting_balance,
            end_balance=self._om._balance,
            total_trades=total_trades,
            win_rate=win_rate,
        )
        return res


// src\lib\enums.py (L278-L282)
from enum import Enum


class TradingPlatform(Enum):
    MT5 = 0

// src\lib\exchanges\__init__.py (L283-L287)
from .backtest_futures_exchange import BacktestFuturesExchange
from .exchange import Exchange
from .futures_exchange import FuturesExchange
from .mt5_exchange import MT5Exchange


// src\lib\exchanges\backtest_futures_exchange.py (L288-L418)
import logging
from decimal import Decimal
from typing import Generator
from uuid import uuid4

import pandas as pd

from core.enums import OrderType, PositionStatus, Side
from lib.typing import MODIFY_SENTINEL, Position, Tick
from .futures_exchange import FuturesExchange


logger = logging.getLogger(__name__)

SENITNEL_POSITION = (
    Position(
        id="tmp",
        instrument="tmp-instrument",
        side=Side.ASK,
        order_type=OrderType.MARKET,
        starting_amount=Decimal("10"),
        price=Decimal("100.0"),
        status=PositionStatus.OPEN,
    ),
)


class BacktestFuturesExchange(FuturesExchange):

    def __init__(
        self,
        login_creds: dict,
        df_path: str | None = None,
        df: pd.DataFrame | None = None,
    ):
        super().__init__(login_creds)
        self._df_path = df_path
        self._df = df

    def login(self) -> bool:
        return True

    def subscribe(self, instrument: str) -> Generator[Tick, None, None]:
        """
        Subscribes to price stream and yields the ticks

        Args:
            instrument (str): Instrument to subscribe to

        Yields:
            Generator[Tick, None, None]: Tick object
        """
        if self._df_path:
            reader = pd.read_csv(self._df_path, chunksize=1000)
            for chunk in reader:
                for dt, row in chunk.iterrows():
                    self._last_tick = Tick(last=row["close"], time=dt)
                    yield self._last_tick
        else:
            for dt, row in self._df.iterrows():                    
                self._last_tick = Tick(last=row["close"], time=dt)
                yield self._last_tick

    def open_position(
        self,
        instrument: str,
        side: Side,
        order_type: OrderType,
        amount: Decimal,
        price: Decimal | None = None,
        limit_price: Decimal | None = None,
        stop_price: Decimal | None = None,
        tp_price: Decimal | None = None,
        sl_price: Decimal | None = None,
    ) -> Position | None:
        return Position(
            id=str(uuid4()),
            instrument=instrument,
            side=side,
            order_type=order_type,
            starting_amount=amount,
            price=price,
            limit_price=limit_price,
            stop_price=stop_price,
            tp_price=tp_price,
            sl_price=sl_price,
            status=(
                PositionStatus.OPEN
                if order_type == OrderType.MARKET
                else PositionStatus.PENDING
            ),
        )

    def modify_position(
        self,
        position: Position,
        limit_price: Decimal | None = MODIFY_SENTINEL,
        stop_price: Decimal | None = MODIFY_SENTINEL,
        tp_price: Decimal | None = MODIFY_SENTINEL,
        sl_price: Decimal | None = MODIFY_SENTINEL,
    ) -> tuple[bool, Position]:
        updated = Position(
            id=position.id,
            instrument=position.instrument,
            side=position.side,
            order_type=position.order_type,
            starting_amount=position.starting_amount,
            price=position.price,
            limit_price=(
                limit_price if limit_price is not None else position.limit_price
            ),
            stop_price=stop_price if stop_price is not None else position.stop_price,
            tp_price=tp_price if tp_price is not None else position.tp_price,
            sl_price=sl_price if sl_price is not None else position.sl_price,
        )
        return (True, updated)

    def close_position(
        self, position: Position, price: Decimal, amount: Decimal
    ) -> tuple[bool, Position]:
        return (True, SENITNEL_POSITION)

    def close_all_positions(self) -> None:
        return

    def cancel_position(self, position_id: str) -> bool:
        return True

    def cancel_all_positions(self) -> None:
        return


// src\lib\exchanges\exchange.py (L419-L455)
from abc import abstractmethod
from typing import Generator

from lib.typing import Tick


class Exchange:
    """ABC for all exchanges"""
    def __init__(self, login_creds: dict):
        self._last_tick: Tick | None = None
        self._login_creds = login_creds

    @abstractmethod
    def login(self) -> bool:
        """
        Performs the requiring login process

        Returns:
            bool: True if successful login
        """

    @abstractmethod
    def subscribe(self, instrument: str) -> Generator[Tick, None, None]:
        """
        Subscribes to price stream and yields the ticks

        Args:
            instrument (str): Instrument to subscribe to

        Yields:
            Generator[Tick, None, None]: Tick object
        """

    @property
    def last_tick(self) -> Tick | None:
        return self._last_tick


// src\lib\exchanges\futures_exchange.py (L456-L504)
from abc import abstractmethod
from decimal import Decimal

from core.enums import OrderType, Side
from lib.typing import MODIFY_SENTINEL, Position
from .exchange import Exchange


class FuturesExchange(Exchange):
    """Abstract base class for a futures trading exchange."""

    @abstractmethod
    def open_position(
        self,
        instrument: str,
        side: Side,
        order_type: OrderType,
        amount: Decimal,
        price: Decimal | None = None,
        limit_price: Decimal | None = None,
        stop_price: Decimal | None = None,
        tp_price: Decimal | None = None,
        sl_price: Decimal | None = None,
    ) -> Position | None: ...

    @abstractmethod
    def modify_position(
        self,
        position: Position,
        limit_price: Decimal | None = MODIFY_SENTINEL,
        stop_price: Decimal | None = MODIFY_SENTINEL,
        tp_price: Decimal | None = MODIFY_SENTINEL,
        sl_price: Decimal | None = MODIFY_SENTINEL,
    ) -> tuple[bool, Position]: ...

    @abstractmethod
    def close_position(
        self, position: Position, price: Decimal, amount: Decimal
    ) -> tuple[bool, Position]: ...

    @abstractmethod
    def close_all_positions(self) -> None: ...

    @abstractmethod
    def cancel_position(self, position_id: str) -> bool: ...

    @abstractmethod
    def cancel_all_positions(self) -> None: ...


// src\lib\exchanges\mt5_exchange.py (L505-L509)
from .futures_exchange import FuturesExchange


class MT5Exchange(FuturesExchange):
    pass

// src\lib\indicators\__init__.py (L510-L512)
from .bos import bearish_bos, bullish_bos
from .fvg import fvg


// src\lib\indicators\bos.py (L513-L626)
from lib.typing import OHLC, BullishBOS, BearishBOS


def bullish_bos(candles: tuple[OHLC, ...]) -> BullishBOS:
    """
    Detect the latest bullish Break of Structure (BOS) in OHLC candles.

    Args:
        candles (tuple[OHLC, ...]): Sequence of OHLC candles.

    Returns:
        BullishBOS: Contains:
            - type (str): 'bullish'
            - present (bool): BOS occurred?
            - first_low_idx (int | None): Index of first swing low.
            - high_idx (int | None): Index of swing high.
            - second_low_idx (int | None): Index of second swing low.
            - breakout_idx (int | None): Index of candle breaking the high.
    """
    n = len(candles)
    first_low, high, second_low = None, None, None
    first_low_idx, high_idx, second_low_idx = None, None, None

    for i in range(n - 2, 0, -1):
        first, second, third = candles[i - 1], candles[i], candles[i + 1]

        if first.low >= second.low <= third.low:
            second_low = second.low
            second_low_idx = i
            first_low_idx, high_idx = None, None
            first_low, high = None, None
        elif high is None and first.high <= second.high >= third.high:
            high = second.high
            high_idx = i
        elif first_low is None and first.low >= second.low <= third.low:
            first_low = second.low
            first_low_idx = i
            break

    present = False
    breakout_idx = None
    if first_low is not None and high is not None and second_low is not None:
        for i in range(second_low_idx, n):
            candle = candles[i]
            if candle.open < high and candle.close > high:
                present = True
                breakout_idx = i
                break

    return BullishBOS(
        type="bullish",
        present=present,
        first_low_idx=first_low_idx,
        high_idx=high_idx,
        second_low_idx=second_low_idx,
        breakout_idx=breakout_idx,
    )


def bearish_bos(candles: tuple[OHLC, ...]) -> BearishBOS:
    """
    Detect the latest bearish Break of Structure (BOS) in OHLC candles.

    Args:
        candles (tuple[OHLC, ...]): Sequence of OHLC candles.

    Returns:
        BearishBOS: Contains:
            - type (str): 'bearish'
            - present (bool): BOS occurred?
            - first_high_idx (int | None): Index of first swing high.
            - low_idx (int | None): Index of swing low.
            - second_high_idx (int | None): Index of second swing high.
            - breakout_idx (int | None): Index of candle breaking the low.
    """
    n = len(candles)
    first_high, low, second_high = None, None, None
    first_high_idx, low_idx, second_high_idx = None, None, None

    for i in range(n - 2, 0, -1):
        first, second, third = candles[i - 1], candles[i], candles[i + 1]

        if second_high is None and first.high <= second.high >= third.high:
            second_high = second.high
            second_high_idx = i
            first_high_idx, low_idx = None, None
            first_high, low = None, None
        elif low is None and first.low >= second.low <= third.low:
            low = second.low
            low_idx = i
        elif first_high is None and first.high <= second.high >= third.high:
            first_high = second.high
            first_high_idx = i
            break

    present = False
    breakout_idx = None
    if first_high is not None and low is not None and second_high is not None:
        for i in range(second_high_idx, n):
            candle = candles[i]
            if candle.open > low and candle.close < low:
                present = True
                breakout_idx = i
                break

    return BearishBOS(
        type="bearish",
        present=present,
        first_high_idx=first_high_idx,
        low_idx=low_idx,
        second_high_idx=second_high_idx,
        breakout_idx=breakout_idx,
    )


// src\lib\indicators\fvg.py (L627-L640)
from lib.typing import FVG, OHLC


def fvg(candles: list[OHLC]) -> FVG | None:
    if len(candles) != 3:
        raise ValueError("Must provide 3 candles.")

    first, last = candles[0], candles[2]

    if first.low > last.high:
        return FVG(above=first.low, below=last.high)
    if first.high < last.low:
        return FVG(above=last.low, below=first.high)


// src\lib\order_manager_registry.py (L641-L655)
from lib.enums import TradingPlatform
from lib.order_managers import FuturesOrderManager, MT5OrderManager


class OrderManagerRegistry:
    _managers = {
        TradingPlatform.MT5: MT5OrderManager,
    }

    @classmethod
    def get(cls, platform: TradingPlatform) -> FuturesOrderManager | None:
        manager = cls._managers.get(platform)
        if manager:
            return manager()


// src\lib\order_managers\__init__.py (L656-L659)
from .backtest_futures_order_manager import BacktestFuturesOrderManager
from .futures_order_manager import FuturesOrderManager
from .mt5_order_manager import MT5OrderManager


// src\lib\order_managers\backtest_futures_order_manager.py (L660-L873)
import heapq
import logging
from decimal import Decimal

from core.enums import OrderType, PositionStatus, Side
from lib.typing import MODIFY_SENTINEL, Position, Tick
from utils import get_datetime
from .futures_order_manager import FuturesOrderManager


logger = logging.getLogger(__name__)


class BacktestFuturesOrderManager(FuturesOrderManager):
    def __init__(self, starting_balance: float = 100_000.0, leverage: int = 10):
        super().__init__()

        if starting_balance is None:
            logger.warning("No starting balance provided")

        self._leverage = leverage
        self._balance = Decimal(str(starting_balance))
        self._equity = Decimal("0.0")
        self._margin = Decimal("0.0")
        self._free_margin = self._balance

        self._closed_positions: list[Position] = []

    def login(self) -> bool:
        return True

    def open_position(
        self,
        instrument: str,
        side: Side,
        order_type: OrderType,
        amount: Decimal,
        price: float | None = None,
        limit_price: float | None = None,
        stop_price: float | None = None,
        tp_price: float | None = None,
        sl_price: float | None = None,
    ) -> str | None:
        if not self._perform_pretrade_risk(amount):
            return None

        pos = self._exchange.open_position(
            instrument,
            side,
            order_type,
            amount,
            price,
            limit_price,
            stop_price,
            tp_price,
            sl_price,
        )
        self._positions[pos.id] = pos
        return pos.id

    def modify_position(
        self,
        position_id: str,
        limit_price: float | None = MODIFY_SENTINEL,
        stop_price: float | None = MODIFY_SENTINEL,
        tp_price: float | None = MODIFY_SENTINEL,
        sl_price: float | None = MODIFY_SENTINEL,
    ) -> bool:
        pos = self._positions.get(position_id)
        if not pos:
            return False

        success, new_pos = self._exchange.modify_position(
            pos, limit_price, stop_price, tp_price, sl_price
        )

        if success:
            self._positions[position_id] = new_pos

        return True

    def close_position(self, position_id: str, price: float, amount: Decimal) -> bool:
        """Simulate position close (remove from active positions)."""
        pos = self._positions.pop(position_id, None)
        if pos is None:
            return False

        if amount > pos.current_amount:
            self._positions[pos.id] = pos
            return False

        pos.unrealised_pnl = self._calc_upl(pos, price, pos.current_amount)
        self._margin -= amount

        if amount == pos.current_amount:
            self._equity -= pos.unrealised_pnl
            pos.current_amount = 0

            self._balance += pos.unrealised_pnl
            pos.realised_pnl += pos.unrealised_pnl
            pos.unrealised_pnl = 0.0

            pos.close_price = price
            pos.closed_at = get_datetime()
            pos.status = PositionStatus.CLOSED
            self._closed_positions.append(pos)
        else:
            pnl = self._calc_upl(pos, price, amount)
            self._balance += pnl
            self._equity -= pnl

            pos.realised_pnl += pnl
            pos.current_amount -= amount
            pos.unrealised_pnl = self._calc_upl(pos, price, pos.current_amount)

            self._positions[pos.id] = pos

        self._free_margin = self._equity - self._margin
        return True

    def close_all_positions(self) -> None:
        price = self._exchange.last_tick.last
        for pos in list(self._positions.values()):
            self.close_position(pos.id, price, pos.current_amount)

    def cancel_position(self, position_id: str) -> bool:
        """Alias for close in backtest context (cancel = remove before fill)."""
        if (
            pos := self._positions.get(position_id)
        ) and pos.status == PositionStatus.PENDING:
            pos = self._positions.pop(pos.id)
            self._margin -= pos.current_amount
            self._free_margin = self._equity - self._margin
            return True

        return False

    def cancel_all_positions(self) -> None:
        """Remove all active positions."""
        for pos in list(self._positions.values()):
            if pos.status == PositionStatus.PENDING:
                self._positions.pop(pos.id)
                self._margin -= pos.current_amount
                self._free_margin = self._equity - self._margin

    def perform_risk_checks(self, tick: Tick) -> bool:
        """
        Updates free margin and performs margin call if
        necessary.

        Args:
            tick (Tick)
        Returns:
            bool: True if there's remaining free margin.
        """
        zero = Decimal("0.0")
        new_equity = zero

        for pos in self._positions.values():
            upnl = self._calc_upl(pos, tick.last, pos.current_amount)
            new_equity += upnl

        self._equity = self._balance + new_equity
        self._free_margin = self._equity - self._margin

        # Closing positions
        if self._free_margin <= zero:
            positions: list[tuple[float, Position]] = []
            for pos in self._positions.values():
                heapq.heappush(positions, (pos.current_amount, pos))

            while self._free_margin <= zero and positions:
                current_amount, pos = positions.pop()

                self._margin -= current_amount
                self._equity -= pos.unrealised_pnl
                self._free_margin = self._equity - self._margin

                pos.realised_pnl += pos.unrealised_pnl
                self._balance += pos.realised_pnl
                pos.unrealised_pnl = zero

                pos.current_amount = zero
                pos.close_price = tick.last
                pos.closed_at = get_datetime()
                pos.status = PositionStatus.CLOSED
                self._positions.pop(pos.id)

        return self._free_margin > zero

    def _perform_pretrade_risk(self, amount: float) -> bool:
        amount = Decimal(str(amount))
        if self._free_margin < amount * self._leverage:
            return False

        self._margin += amount
        self._free_margin -= amount
        return True

    def _calc_upl(self, pos: Position, close_price: float, amount: float):
        total_amount = Decimal(str(amount * self._leverage))
        open_price = pos.price or pos.limit_price or pos.stop_price

        try:
            if pos.side == Side.ASK:
                pct = (open_price - close_price) / open_price
            else:
                pct = (close_price - open_price) / open_price
        except ZeroDivisionError:
            pct = 0.0

        upnl = Decimal(str(pct)) * total_amount
        return upnl


// src\lib\order_managers\futures_order_manager.py (L874-L938)
from abc import abstractmethod
from decimal import Decimal

from core.enums import OrderType, Side
from lib.exchanges import FuturesExchange
from lib.typing import MODIFY_SENTINEL, Position


class FuturesOrderManager:
    _exchange: FuturesExchange

    def __init__(self):
        self._positions: dict[str, Position] = {}

    @abstractmethod
    def login(self) -> bool: ...

    @abstractmethod
    def open_position(
        self,
        instrument: str,
        side: Side,
        order_type: OrderType,
        amount: Decimal,
        price: float | None = None,
        limit_price: float | None = None,
        stop_price: float | None = None,
        tp_price: float | None = None,
        sl_price: float | None = None,
    ) -> str | None:
        """
        Returns the position id or None if position
        couldn't be placed
        """

    @abstractmethod
    def modify_position(
        self,
        position_id: str,
        limit_price: float | None = MODIFY_SENTINEL,
        stop_price: float | None = MODIFY_SENTINEL,
        tp_price: float | None = MODIFY_SENTINEL,
        sl_price: float | None = MODIFY_SENTINEL,
    ) -> bool: ...

    """Returns whether or not the call was successfull"""

    @abstractmethod
    def close_position(
        self, position_id: str, price: float, amount: Decimal
    ) -> bool: ...

    @abstractmethod
    def close_all_positions(self) -> None: ...

    @abstractmethod
    def cancel_position(self, position_id: str) -> bool: ...

    @abstractmethod
    def cancel_all_positions(self) -> None: ...

    @property
    def positions(self):
        return self._positions.values()


// src\lib\order_managers\mt5_order_manager.py (L939-L944)
from .futures_order_manager import FuturesOrderManager


class MT5OrderManager(FuturesOrderManager):
    pass


// src\lib\strategy.py (L945-L996)
from abc import abstractmethod

from core.enums import StrategyType
from lib.enums import TradingPlatform
from lib.order_manager_registry import OrderManagerRegistry
from lib.typing import Tick


class Strategy:
    """
    Base class for all startegies. The run method is called
    when a new tick comes in
    """

    def __init__(
        self,
        type: StrategyType,
        platform: TradingPlatform,
        instrument: str,
        pip_size: float = 0.0001,
    ):
        self._type = type
        self._om = OrderManagerRegistry.get(platform)
        self._instrument = instrument.lower()
        self._pip_size = pip_size

    @abstractmethod
    def run(self, tick: Tick): ...

    def shutdown(self):
        """
        Contains any necessary shutdown logic. For example
        closing all positions and / or orders.
        """

    def startup(self):
        """
        Pretrade logic to be ran before receiving ticks
        """
        self._om.login()

    def __enter__(self):
        self.startup()
        return self

    def __exit__(self, exc_type, exc_value, tcb):
        self.shutdown()

    @property
    def type(self) -> StrategyType:
        return self._type


// src\lib\typing.py (L997-L1078)
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from typing import Literal, NamedTuple

from core.enums import OrderType, PositionStatus, Side
from utils import get_datetime


BullishBearish = Literal["bullish", "bearish"]


class Tick(NamedTuple):
    last: float
    time: datetime


class OHLC(NamedTuple):
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal


class FVG(NamedTuple):
    above: Decimal
    below: Decimal


class BullishBOS(NamedTuple):
    type: str
    present: bool
    first_low_idx: int
    high_idx: int
    second_low_idx: int
    breakout_idx: int


class BearishBOS(NamedTuple):
    type: str
    present: bool
    first_high_idx: int
    low_idx: int
    second_high_idx: int
    breakout_idx: int


# TODO: Add support for partials
@dataclass
class Position:
    id: str
    instrument: str
    side: Side
    order_type: OrderType
    starting_amount: Decimal
    current_amount: Decimal = None
    price: float | None = None
    limit_price: float | None = None
    stop_price: float | None = None
    tp_price: float | None = None
    sl_price: float | None = None
    realised_pnl: Decimal | None = Decimal("0.0")
    unrealised_pnl: Decimal | None = Decimal("0.0")
    status: PositionStatus = PositionStatus.PENDING
    created_at: datetime | None = field(default_factory=get_datetime)
    close_price: float | None = None
    closed_at: datetime | None = None

    def __post_init__(self):
        self.current_amount = self.starting_amount


@dataclass
class BacktestResult:
    total_pnl: Decimal
    starting_balance: Decimal
    end_balance: Decimal
    total_trades: int
    win_rate: float


MODIFY_SENTINEL = '*'

// src\utils.py (L1079-L1113)
from contextlib import asynccontextmanager, contextmanager
from datetime import UTC, datetime
from typing import AsyncGenerator, Generator

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import sessionmaker, Session

from config import DB_ENGINE, DB_ENGINE_SYNC


smaker = sessionmaker(DB_ENGINE, class_=AsyncSession, autocommit=False, autoflush=False)
smaker_sync = sessionmaker(DB_ENGINE_SYNC, class_=Session, autocommit=False, autoflush=False)


def get_datetime():
    return datetime.now(UTC)


@asynccontextmanager
async def get_db_sess() -> AsyncGenerator[AsyncSession, None]:
    async with smaker.begin() as s:
        try:
            yield s
        except:
            await s.rollback()
            raise

@contextmanager
def get_db_sess_sync() -> Generator[Session, None, None]:
    with smaker_sync.begin() as sess:
        try:
            yield sess
        except:
            sess.rollback()
            raise



Example prompt and output:

Prompt:
Build me a strategy that longs when price is greater than the previous and vice versa
for shorts. Maintaining no more than 1 open position at a time.

Output:
from decimal import Decimal

from sqlalchemy import select

from core.enums import OrderType, Side, StrategyType
from db_models import Ticks
from lib import Backtest, Strategy, TradingPlatform
from lib.typing import Tick
from utils import get_db_sess_sync


class UserStrategy(Strategy):
    """
    A simple strategy that longs when the current tick
    price is lower than the previous and vice versa for shorts
    """
    def __init__(self, type, platform, instrument, pip_size=0.0001):
        super().__init__(
            type=type, platform=platform, instrument=instrument, pip_size=pip_size
        )
        self._last_price: Decimal | None = None
        self._placed = False

    def startup(self):
        with get_db_sess_sync() as db_sess:
            prev_tick = db_sess.scalar(
                select(Ticks)
                .where(Ticks.instrument == self._instrument)
                .order_by(Ticks.time.desc())
                .limit(1)
            )

        if prev_tick:
            self._last_price = prev_tick.last_price

    def shutdown(self):
        self._om.cancel_all_positions()
        self._om.close_all_positions()

    def run(self, tick: Tick) -> None:
        if self._last_price is None or self._om.positions:
            self._last_price = tick.last
            return

        if tick.last < self._last_price:
            success = self._om.open_position(
                self._instrument,
                Side.BID,
                OrderType.MARKET,
                Decimal("10.0"),
                tick.last,
                tp_price=1.13008,
            )
            if success:
                self._placed = True
        self._last_price = tick.last


Example backtest with example output:
"""
An example of how backtests are run
"""

from decimal import Decimal

from sqlalchemy import select

from core.enums import OrderType, Side, StrategyType
from db_models import Ticks
from lib import Backtest, Strategy, TradingPlatform
from lib.typing import Tick
from utils import get_db_sess_sync


class UserStrategy(Strategy):
    """
    A simple strategy that longs when the current tick
    price is lower than the previous and vice versa for shorts
    """
    def __init__(self, type, platform, instrument, pip_size=0.0001):
        super().__init__(
            type=type, platform=platform, instrument=instrument, pip_size=pip_size
        )
        self._last_price: Decimal | None = None
        self._placed = False

    def startup(self):
        with get_db_sess_sync() as db_sess:
            prev_tick = db_sess.scalar(
                select(Ticks)
                .where(Ticks.instrument == self._instrument)
                .order_by(Ticks.time.desc())
                .limit(1)
            )

        if prev_tick:
            self._last_price = prev_tick.last_price

    def shutdown(self):
        self._om.cancel_all_positions()
        self._om.close_all_positions()

    def run(self, tick: Tick) -> None:
        if self._last_price is None or self._om.positions:
            self._last_price = tick.last
            return

        if tick.last < self._last_price:
            success = self._om.open_position(
                self._instrument,
                Side.BID,
                OrderType.MARKET,
                Decimal("10.0"),
                tick.last,
                tp_price=1.13008,
            )
            if success:
                self._placed = True
        self._last_price = tick.last


def main():
    import os
    import pandas as pd    
    import sys
    sys.path.append(os.path.join(os.path.dirname(os.path.dirname(__file__)), "src"))
    from config import RESOURCES_PATH

    def startup(*args, **kw):
        nonlocal strat
        if not strat._om.login():
            raise ValueError("Unsuccessful login")

    fp = os.path.join(RESOURCES_PATH, "price-data", "EURUSD1.csv")
    eur_df = pd.read_csv(fp)
    eur_df.set_index("datetime", inplace=True)

    strat = UserStrategy(StrategyType.FUTURES, TradingPlatform.MT5, "EURUSD")
    strat.startup = startup
    bt = Backtest(strat, df=eur_df)
    results = bt.run()
    print(results)


if __name__ == "__main__":
    main()
